
## 1. General Development Rules

### Platform Requirements

* **Windows Only**

    * All commands must be compatible with **PowerShell**.
    * Scripts, environment setup, and automation should never assume Bash or Unix tooling.
* **Gradle Usage**

    * Always use the system-installed `gradle` from the environment.
    * Do **not** use `gradlew` wrapper scripts.

---

### Code Style

* **Self-Documenting Code**

    * Write **verbose, descriptive, and expressive** code.
    * Never add inline comments – the code itself must explain its purpose.
* **Naming Conventions**

    * Classes: `*Service`, `*Repository`, `*UseCase`, `*ViewModel`.
    * Interfaces: prefixed with `I` (e.g., `INotificationService`).
    * Methods: action-driven (`performSyncTask`, `connectToDevice`, `initializeService`).
* **Immutability**

    * All state updates must return **new objects**.
    * Reducers and ViewModels must never mutate state directly.
* **Error Handling**

    * Always use `try/catch/finally`.
    * Errors must propagate with **clear, descriptive messages**.

---

### Development Approach

* **Efficiency-Driven**

    * Research the most effective approach before implementation.
    * Avoid redundant logic and unnecessary operations.
* **Maintainability**

    * Prioritize clarity and long-term maintainability over micro-optimizations.
* **Consistency**

    * Follow the same code style, folder structure, and architectural patterns across all features.

---

## 2. Architecture & Patterns

### Feature-First Architecture

* Each feature has its **own isolated stack**:

    * **Data**: repositories, database access
    * **Domain**: use cases (business logic)
    * **Services**: feature integrations
    * **Presentation**: ViewModel + UI components
* Shared functionality lives in **`core/`**:

    * Core repositories
    * Shared services (e.g., Notifications, Background Sync)
    * Dependency Injection

### Clean Architecture Layers

1. **Data Layer** → persistence, APIs, repositories
2. **Domain Layer** → use cases, pure business rules
3. **Service Layer** → orchestration, external integrations
4. **Presentation Layer** → ViewModels, React components

### Dependency Injection

* All services and repositories are provided via **React Context**.
* Access services only through custom hooks (e.g., `useNotification`, `useBluetoothService`).

### Repository Pattern

* Repositories define contracts via interfaces.
* Implementations abstract persistence and networking.
* Business logic must never directly depend on raw database or APIs.

### Service Orchestration

* Specialized service classes coordinate dependencies.
* Examples:

    * `AppInitializer` → bootstraps all core services.
    * `NotificationManager` → coordinates permissions and notifications.
    * `FCMMessageHandler` → processes incoming messages.

---

#### Structure Rules
### Preferred Project Structure

The following folder structure enforces **feature-first organization** and **clean architecture layers**:

1. **Core vs. Features**
    * `core/` contains **shared services, repositories, DI, and infrastructure**.
    * `features/` contains **isolated vertical slices** (data, domain, services, presentation).

2. **Feature Layering**
    * **data/** → repositories, DTOs, persistence
    * **domain/** → pure business logic (use cases)
    * **services/** → orchestration + external integration
    * **presentation/** → ViewModels, hooks, React components

3. **Naming Conventions**
    * Classes: `*Service`, `*Repository`, `*UseCase`, `*ViewModel`
    * Interfaces: `I*` (e.g., `INotificationService`)
    * Screens: `FeatureScreen.tsx`
    * Hooks: `useFeatureViewModel.ts`

4. **Scalability**
    * Every new feature **must follow the same layered structure**.
    * Cross-feature imports are forbidden; only `core/` is shared.

## 3. State Management (MVI)

### MVI Pattern

* **Model (State):** Immutable state objects.
* **View (UI):** Pure React components consuming state.
* **Intent (Actions):** User interactions → reducer actions.

### ViewModel Guidelines

* Each feature has its **own ViewModel**.
* Responsibilities:

    * Provide `getInitialState()` and `reducer()`.
    * Handle async flows (`performSyncTask`, `requestPermission`).
    * Expose strongly-typed **actions** to the UI.

### Reducer Rules

* Reducers must be **pure functions**.
* Each action must represent a **clear state transition**.
* Side effects must not be placed inside reducers.

### Hooks

* Wrap ViewModels with feature-specific hooks (`useHomeViewModel`, `useBluetoothViewModel`).
* Hooks handle dependency injection internally.
* Avoid exposing raw services directly to UI components.

---

## 4. Testing Guidelines

### Testing Approach

* **BDD (Behavior-Driven Development)**

    * Write tests that describe behavior, not implementation.
    * Use `given → when → then` structure.

### Unit Tests

* Mock repositories and services via interfaces.
* Test reducers and ViewModels in isolation.

### Service Tests

* Verify orchestration and integration flows.
* Ensure error handling and retry mechanisms behave correctly.

### UI Tests

* Test integration between hooks and state transitions.
* Focus on user interactions, not implementation details.

---

## 5. Best Practices

* **Feature Isolation**

    * Never import across features.
    * Shared logic belongs in `core/`.
* **Interfaces + DI**

    * Always program against interfaces for testability.
* **Error-First Mindset**

    * Handle edge cases before happy paths.
* **Factories**

    * Use factories for manual service creation when needed.
* **Logging**

    * Wrap logging in hooks if needed (e.g., `useConsoleLogger`).
* **Navigation**

    * Keep screen navigation isolated in `App.tsx` or a router file.
* **Scalability**

    * New features must follow the same folder and architectural pattern.

---


## 6. UI/UX Guidelines

### Material Design

* **Always follow Material Design principles** for all UI components.
* Use the official **React Native Material Design libraries** `react-native-material/core`.
* All screens must have consistent:
    * **Typography** (Material styles for headings, body, captions)
    * **Color scheme** (primary, secondary, surface, background, error)
    * **Elevation and shadows** (cards, dialogs, floating buttons)
    * **Shape system** (rounded corners, consistent spacing)
* Avoid using raw, unstyled `View`, `Text`, or `Button` unless wrapped in Material components.

### Navigation & Interaction

* Navigation should follow **Material Navigation guidelines**:
    * Bottom navigation for 3–5 primary destinations.
    * Drawer navigation only for secondary destinations.
* User actions must be discoverable:
    * **FAB (Floating Action Button)** for primary contextual actions.
    * **Snackbars** for transient feedback instead of alerts.
* All interactions must provide **visual feedback** (ripple, elevation change).

✅ **Summary**

* Global rules enforce **Windows PowerShell support**, **gradle from environment**, and **self-explanatory code**.
* React Native code must follow **feature-first clean architecture** with **MVI state management**.
* **Repositories, Services, and ViewModels** are the foundation of business logic.
* **Tests follow BDD** with isolation, mocking, and cleanup.
* Every feature is **scalable, testable, and maintainable**.

---
